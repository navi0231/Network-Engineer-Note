## 2.9.1 检错码

#### 奇偶检验
- 做法：在数据末尾多加一位“校验位”
- 原理：在7位的ASCII代码后增加一位
- 分为*奇校验*和*偶校验*
- 局限性：只能检测出奇数个比特位的错误。如果两位同时翻转，1 的个数奇偶性不变，接收方就发现不了错误

#### 校验和
- 做法：将原始数据分成若干个固定长度的块，把它们相加，最后取反得到一个“和"
- 验证：接收方把数据和校验和全部加起来，如果结果全为 1，则认为数据正确
- 例子：
> 为了让验证更简单，很多协议（如 Intel Hex 格式）会使用 256 的补码作为校验和：
> - 算出余数 104。
> - 用 256 - 104 = 152。
> - 将 152 作为校验和。

## 2.9.2 海明码
- *一不等式，二位置规则，三计算步骤*

**一不等式**
- 假设数据位是n位，校验位是k位，总位数是k位必须满足：
    - $$2^k \ge m + k + 1$$
       - $$n = m + k$$

**二位置规则**
校验位必须放置在 $2^i$ 的位置上，其余位置留给数据位。

| 位置 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **角色** | ***P1*** | ***P2*** | D1 | ***P4*** | D2 | D3 | D4 |

> 校验位 $P_i$ 的下标 $i$ 必须是 $2^n$ （如 1, 2, 4, 8...），代表其所在的位置编号

**三计算步骤**
1. **写出位置编号的二进制**（如位置 7 为 `111`）。
2. **分配校验组**：校验位 $P_i$ 负责所有二进制编号中第 $i$ 位为 1 的位置。

| 校验位 | 权值 | 管辖位置的二进制 (加粗位为 1 则归该 P 管) | 对应十进制 |
| :--- | :--- | :--- | :--- |
| **P1** | 1 | 00**1**, 01**1**, 10**1**, 11**1** | 1, 3, 5, 7 |
| **P2** | 2 | 0**1**0, 0**1**1, 1**1**0, 1**1**1 | 2, 3, 6, 7 |
| **P4** | 4 | **1**00, **1**01, **1**10, **1**11 | 4, 5, 6, 7 |

> **逻辑**：只要位置编号的二进制里，对应的权值位是就属于该校验位的“领地”

3. **异或求和**：将校验结果 $G_4 G_2 G_1$ 排列，所得十进制数即为错误位置
- 计算校验因子：
   > - $G_1 = P_1 \oplus (3, 5, 7位)$
   > - $G_2 = P_2 \oplus (3, 6, 7位)$
   > - $G_4 = P_4 \oplus (5, 6, 7位)$
- 结果判定：
   > - 将结果排列为二进制 $G_4 G_2 G_1$。
   > - 若为 `000`，数据正确。
   > - 若不为 `0`，结果对应的十进制数即为**出错位置**

## 2.9.3 循环冗余校验（CRC）

**基础概念**
- 目的：检测数据中在传输中是否有位元翻转
- 手段：模2除法(Modulo-2 Division)
- 结果：生成挂在数据末尾的FCS(帧校验序列)

**具体步骤**
- 第一步：多项式“翻译” (确定除数)
> - 规则：指数是几，第几位就是 1，其余补 0
> - 以 $G(x) = X^4 + X + 1$ 为例子：

> | 指数 (权位) | 4 | 3 | 2 | 1 | 0 |
> | :--- | :---: | :---: | :---: | :---: | :---: |
> | **是否存在** | 是 ($X^4$) | 否 | 否 | 是 ($X^1$) | 是 ($1$) |
> | 二进位位 | **1** | 0 | 0 | **1** | **1** |

> 最终除数是`10011`

- 第二步：补零 (预留位置)
> - 规则：**除数**是 $n$ 位，就在*原始数据*后面补 $n-1$ 个 0
> - 范例：除数 10011 (5位)，原始数据 1101
> - 补零后：1101 0000

- 第三步：模 2 除法 (核心算法)
>   - 口诀：相同得 0，不同得 1；不借位，只管首位
>   - 首位是 1：商 1，对应位置进行异或
>   - 首位是 0：商 0，除数变全 0 进行异或

- 第四步：拼接发送
> - 将最后算出的*余数*（长度必须是 n−1 位）替换掉刚才补的零
> - 发送数据 = 原始数据 + FCS
